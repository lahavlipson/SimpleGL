#ifndef glp_h
#define glp_h
// created by Ethan Lipson
// see: https://www.ethanlipson.com/glp
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <vector>

#define PI 3.141592653589
#define EPSILON 0.0000000001



inline void pushBackVec3(std::vector<double> &vertices, glm::dvec3 vec) {
    for (int i = 0; i < 3; i++) {
        vertices.push_back(vec[i]);
    }
}



namespace glp {
    /** Creates a sphere by recursively dividing the faces
     * of an octahedron [accuracy] number of times, and then
     * normalizes all of the vertices.
     * Surface normals are generated by normalizing each vertex.
     * Origin is the geometric center of the sphere by default. */
    inline std::vector<double> sphere(int accuracy, double r, glm::dvec3 pos = { 0, 0, 0 });
    
    /** The base for pyramids, cones, and cylinders
     * Creates a truncated cone. The top base has radius [r1]
     * and the bottom base has radius [r2].
     * Surface ormals are generated by revolving a base normal
     * around the object.
     * Origin is the center of the bottom face by default. */
    inline std::vector<double> truncatedCone(int accuracy, double h, double r1, double r2, glm::dvec3 pos = { 0, 0, 0 });
    
    /** Truncated cylinder, but the radii are the same.
     * Origin is the center of the bottom face by default. */
    inline std::vector<double> cylinder(int accuracy, double h, double r, glm::dvec3 pos = { 0, 0, 0 });
    
    /** Truncated cylinder, but [r1] is 0.0000000001
     * (making it 0 causes vector and matrix product issues).
     * Origin is the center of the bottom face by default. */
    inline std::vector<double> cone(int accuracy, double h, double r, glm::dvec3 pos = { 0, 0, 0 });
    
    /** The same as the cone function, but without smooth surface normals.
     * Origin is the center of the base by default. */
    inline std::vector<double> pyramid(int sides, double h, double r, glm::dvec3 pos = { 0, 0, 0 });
    
    /** Creates a torus by creating [a1] vertices of distance [r1] from [pos],
     * and then creating [a2] vertices of distance [r2] from each vertex.
     * Origin is the geometric center by default. */
    inline std::vector<double> torus(int a1, int a2, double r1, double r2, glm::dvec3 pos = { 0, 0, 0 });
    
    /** Creates a box with with dimensions [dimensions].
     * The back bottom left corner is [pos].
     * Origin is the geometric center by default. */
    inline std::vector<double> box(glm::dvec3 dimensions, glm::dvec3 pos = { 0, 0, 0 });
    
    /** Function used to generate a sphere.
     * Recursively divides each triangle in [vertices] into four
     * smaller triangles [iters] times, then returns the new vertices */
    inline std::vector<double> splitTriangle(std::vector<double> vertices, int iters);
    
    /** Returns the midpoint between [a] and [b] */
    inline glm::dvec3 mid(glm::dvec3 a, glm::dvec3 b);
}



glm::dvec3 glp::mid(glm::dvec3 a, glm::dvec3 b) {
    return glm::dvec3((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);
}

std::vector<double> glp::splitTriangle(std::vector<double> vertices, int iters) {
    if (iters == 0)
        return vertices;

    std::vector<double> newVertices;

    for (int i = 0; i < vertices.size(); i += 9) {
        glm::dvec3 p1(vertices[i], vertices[i + 1], vertices[i + 2]);
        glm::dvec3 p2(vertices[i + 3], vertices[i + 4], vertices[i + 5]);
        glm::dvec3 p3(vertices[i + 6], vertices[i + 7], vertices[i + 8]);
        glm::dvec3 p4 = mid(p1, p2);
        glm::dvec3 p5 = mid(p2, p3);
        glm::dvec3 p6 = mid(p3, p1);

        pushBackVec3(newVertices, p1);
        pushBackVec3(newVertices, p4);
        pushBackVec3(newVertices, p6);

        pushBackVec3(newVertices, p4);
        pushBackVec3(newVertices, p2);
        pushBackVec3(newVertices, p5);

        pushBackVec3(newVertices, p6);
        pushBackVec3(newVertices, p5);
        pushBackVec3(newVertices, p3);

        pushBackVec3(newVertices, p4);
        pushBackVec3(newVertices, p5);
        pushBackVec3(newVertices, p6);
    }

    return splitTriangle(newVertices, iters - 1);
}

std::vector<double> glp::sphere(int accuracy, double r, glm::dvec3 pos) {
    std::vector<double> vertices = {
        -1.0,  0.0,  0.0,
        0.0,  0.0,  1.0,
        0.0,  1.0,  0.0,

        0.0,  1.0,  0.0,
        0.0,  0.0,  1.0,
        1.0,  0.0,  0.0,

        1.0,  0.0,  0.0,
        0.0,  0.0, -1.0,
        0.0,  1.0,  0.0,

        0.0,  1.0,  0.0,
        0.0,  0.0, -1.0,
        -1.0,  0.0,  0.0,

        /****************/

        0.0, -1.0,  0.0,
        0.0,  0.0,  1.0,
        -1.0,  0.0,  0.0,

        1.0,  0.0,  0.0,
        0.0,  0.0,  1.0,
        0.0, -1.0,  0.0,

        0.0, -1.0,  0.0,
        0.0,  0.0, -1.0,
        1.0,  0.0,  0.0,

        -1.0,  0.0,  0.0,
        0.0,  0.0, -1.0,
        0.0, -1.0,  0.0
    };

    vertices = splitTriangle(vertices, accuracy);
    std::vector<double> newVertices;

    for (int i = 0; i < vertices.size(); i += 3) {
        glm::dvec3 vertex(vertices[i], vertices[i + 1], vertices[i + 2]);
        glm::vec3 norm = glm::normalize(vertex);
        vertex = glm::normalize(vertex) * r;
        vertex += pos;

        pushBackVec3(newVertices, vertex);
        pushBackVec3(newVertices, norm);
    }

    return newVertices;
}

///***************************************************/

std::vector<double> glp::truncatedCone(int accuracy, double h, double r1, double r2, glm::dvec3 pos) {
    std::vector<double> angles;
    std::vector<double> vertices;

    for (int i = 0; i < accuracy + 1; i++) {
        angles.push_back(2 * i * PI / accuracy);
    }

    glm::dvec3 p1(0, 0, r1);
    glm::dvec3 p2(0, h, r2);
    glm::dvec3 p3(sin(angles[1]) * r2, h, cos(angles[1]) * r2);
    glm::dvec3 originalNorm = glm::cross(p1 - p2, p3 - p2);

    for (int i = 0; i < accuracy; i++) {
        glm::dvec3 p1(sin(angles[i]) * r1, 0.0, cos(angles[i]) * r1);
        glm::dvec3 p2(sin(angles[i]) * r2, h, cos(angles[i]) * r2);
        glm::dvec3 p3(sin(angles[i + 1]) * r2, h, cos(angles[i + 1]) * r2);
        glm::dvec3 p4(sin(angles[i + 1]) * r1, 0.0, cos(angles[i + 1]) * r1);

        glm::dvec3 n1 = glm::dmat3(glm::rotate(glm::dmat4(), angles[i], glm::dvec3(0, 1, 0))) * originalNorm;
        glm::dvec3 n2 = glm::dmat3(glm::rotate(glm::dmat4(), angles[i + 1], glm::dvec3(0, 1, 0))) * originalNorm;



        pushBackVec3(vertices, p2);
        pushBackVec3(vertices, n1);

        pushBackVec3(vertices, p1);
        pushBackVec3(vertices, n1);

        pushBackVec3(vertices, p3);
        pushBackVec3(vertices, n2);

        /***************************/

        pushBackVec3(vertices, p4);
        pushBackVec3(vertices, n2);

        pushBackVec3(vertices, p3);
        pushBackVec3(vertices, n2);

        pushBackVec3(vertices, p1);
        pushBackVec3(vertices, n1);

        /***************************/

        glm::dvec3 up(0, 1, 0);
        glm::dvec3 down(0, -1, 0);
        glm::dvec3 top(0, h, 0);

        pushBackVec3(vertices, p3);
        pushBackVec3(vertices, up);

        pushBackVec3(vertices, top);
        pushBackVec3(vertices, up);

        pushBackVec3(vertices, p2);
        pushBackVec3(vertices, up);

        /***************************/

        pushBackVec3(vertices, p1);
        pushBackVec3(vertices, down);

        pushBackVec3(vertices, glm::dvec3(0));
        pushBackVec3(vertices, down);

        pushBackVec3(vertices, p4);
        pushBackVec3(vertices, down);
    }

    for (int i = 0; i < vertices.size(); i += 6) {
        for (int j = 0; j < 3; j++) {
            vertices[i + j] += pos[j];
        }
    }

    return vertices;
}

/***************************************************/

std::vector<double> glp::cylinder(int accuracy, double h, double r, glm::dvec3 pos) {
    return truncatedCone(accuracy, h, r, r, pos);
}

/***************************************************/

std::vector<double> glp::cone(int accuracy, double h, double r, glm::dvec3 pos) {
    std::vector<double> angles;
    std::vector<double> vertices;

    for (int i = 0; i < accuracy + 1; i++) {
        angles.push_back(2 * i * PI / accuracy);
    }

    glm::dvec3 p1(0, 0, r);
    glm::dvec3 p2(0, h, EPSILON);
    glm::dvec3 p3(sin(angles[1]) * EPSILON, h, cos(angles[1]) * EPSILON);
    glm::dvec3 originalNorm = glm::cross(p1 - p2, p3 - p2);

    for (int i = 0; i < accuracy; i++) {
        glm::dvec3 p1(sin(angles[i]) * r, 0.0, cos(angles[i]) * r);
        glm::dvec3 p2(sin(angles[i]) * EPSILON, h, cos(angles[i]) * EPSILON);
        glm::dvec3 p3(sin(angles[i + 1]) * r, 0.0, cos(angles[i + 1]) * r);

        glm::dvec3 n1 = glm::dmat3(glm::rotate(glm::dmat4(), angles[i], glm::dvec3(0, 1, 0))) * originalNorm;
        glm::dvec3 n2 = glm::dmat3(glm::rotate(glm::dmat4(), (angles[i] + angles[i + 1]) / 2, glm::dvec3(0, 1, 0))) * originalNorm;
        glm::dvec3 n3 = glm::dmat3(glm::rotate(glm::dmat4(), angles[i + 1], glm::dvec3(0, 1, 0))) * originalNorm;

        pushBackVec3(vertices, p3);
        pushBackVec3(vertices, n3);

        pushBackVec3(vertices, p2);
        pushBackVec3(vertices, n2);

        pushBackVec3(vertices, p1);
        pushBackVec3(vertices, n1);

        /***************************/

        glm::dvec3 down(0, -1, 0);

        pushBackVec3(vertices, p1);
        pushBackVec3(vertices, down);

        pushBackVec3(vertices, glm::dvec3(0));
        pushBackVec3(vertices, down);

        pushBackVec3(vertices, p3);
        pushBackVec3(vertices, down);
    }

    for (int i = 0; i < vertices.size(); i += 6) {
        for (int j = 0; j < 3; j++) {
            vertices[i + j] += pos[j];
        }
    }

    return vertices;
}

/***************************************************/

std::vector<double> glp::pyramid(int sides, double h, double r, glm::dvec3 pos) {
    std::vector<double> angles;
    std::vector<double> vertices;

    for (int i = 0; i < sides + 1; i++) {
        angles.push_back(2 * i * PI / sides);
    }

    glm::dvec3 p1(0, 0, r);
    glm::dvec3 p2(0, h, EPSILON);
    glm::dvec3 p3(sin(angles[1]) * EPSILON, h, cos(angles[1]) * EPSILON);
    glm::dvec3 originalNorm = glm::cross(p1 - p2, p3 - p2);

    for (int i = 0; i < sides; i++) {
        glm::dvec3 p1(sin(angles[i]) * r, 0.0, cos(angles[i]) * r);
        glm::dvec3 p2(sin(angles[i]) * EPSILON, h, cos(angles[i]) * EPSILON);
        glm::dvec3 p3(sin(angles[i + 1]) * r, 0.0, cos(angles[i + 1]) * r);

        glm::dvec3 norm = glm::dmat3(glm::rotate(glm::dmat4(),
                                                 (angles[i] + angles[i + 1]) / 2, glm::dvec3(0, 1, 0))) * originalNorm;

        pushBackVec3(vertices, p3);
        pushBackVec3(vertices, norm);

        pushBackVec3(vertices, p2);
        pushBackVec3(vertices, norm);

        pushBackVec3(vertices, p1);
        pushBackVec3(vertices, norm);

        /***************************/

        glm::dvec3 down(0, -1, 0);

        pushBackVec3(vertices, p1);
        pushBackVec3(vertices, down);

        pushBackVec3(vertices, glm::dvec3(0));
        pushBackVec3(vertices, down);

        pushBackVec3(vertices, p3);
        pushBackVec3(vertices, down);
    }

    for (int i = 0; i < vertices.size(); i += 6) {
        for (int j = 0; j < 3; j++) {
            vertices[i + j] += pos[j];
        }
    }

    return vertices;
}

/***************************************************/

std::vector<double> glp::torus(int a1, int a2, double r1, double r2, glm::dvec3 pos) {
    std::vector<double> vertices;
    std::vector<double> outerAngles;

    glm::dvec3 originalNorm(0, 0, 1);

    for (int i = 0; i < a1 + 1; i++) {
        outerAngles.push_back(2 * PI * i / a1);
    }

    for (int i = 0; i < a1; i++) {
        std::vector<double> innerAngles;
        glm::dmat3 rotationMat1 = glm::rotate(glm::dmat4(), outerAngles[i], glm::dvec3(0, 1, 0));
        glm::dmat3 rotationMat2 = glm::rotate(glm::dmat4(), outerAngles[i + 1], glm::dvec3(0, 1, 0));
        glm::dvec3 rotationAxis = glm::cross(rotationMat1 * originalNorm, glm::dvec3(0, 1, 0));

        for (int i = 0; i < a2 + 1; i++) {
            innerAngles.push_back(2 * PI * i / a2);
        }

        for (int j = 0; j < a2; j++) {
            glm::dvec3 p1(0, sin(innerAngles[j]) * r2, cos(innerAngles[j]) * r2);
            glm::dvec3 p2(0, sin(innerAngles[j + 1]) * r2, cos(innerAngles[j + 1]) * r2);
            glm::dvec3 p3(0, sin(innerAngles[j + 1]) * r2, cos(innerAngles[j + 1]) * r2);
            glm::dvec3 p4(0, sin(innerAngles[j]) * r2, cos(innerAngles[j]) * r2);

            p1 = rotationMat1 * p1;
            p2 = rotationMat1 * p2;
            p3 = rotationMat2 * p3;
            p4 = rotationMat2 * p4;

            p1 += glm::dvec3(sin(outerAngles[i]) * r1, 0, cos(outerAngles[i]) * r1);
            p2 += glm::dvec3(sin(outerAngles[i]) * r1, 0, cos(outerAngles[i]) * r1);
            p3 += glm::dvec3(sin(outerAngles[i + 1]) * r1, 0, cos(outerAngles[i + 1]) * r1);
            p4 += glm::dvec3(sin(outerAngles[i + 1]) * r1, 0, cos(outerAngles[i + 1]) * r1);

            glm::dmat3 rotationMat3 = glm::rotate(glm::dmat4(), innerAngles[j], rotationAxis);
            glm::dmat3 rotationMat4 = glm::rotate(glm::dmat4(), innerAngles[j + 1], rotationAxis);

            glm::dvec3 n1 = rotationMat1 * originalNorm;
            glm::dvec3 n2 = rotationMat1 * originalNorm;
            glm::dvec3 n3 = rotationMat2 * originalNorm;
            glm::dvec3 n4 = rotationMat2 * originalNorm;

            n1 = rotationMat3 * n1;
            n2 = rotationMat4 * n2;
            n3 = rotationMat4 * n3;
            n4 = rotationMat3 * n4;

            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, n3);

            pushBackVec3(vertices, p2);
            pushBackVec3(vertices, n2);

            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, n1);

            /***************************/

            pushBackVec3(vertices, p4);
            pushBackVec3(vertices, n4);

            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, n3);

            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, n1);
        }
    }

    for (int i = 0; i < vertices.size(); i += 6) {
        for (int j = 0; j < 3; j++) {
            vertices[i + j] += pos[j];
        }
    }

    return vertices;
}

/***************************************************/

std::vector<double> glp::box(glm::dvec3 dimensions, glm::dvec3 pos) {
    std::vector<double> vertices;

    for (double x = 0; x <= dimensions.x; x += dimensions.x) {
        glm::dvec3 p1(x, 0, 0);
        glm::dvec3 p2(x, 0, dimensions.z);
        glm::dvec3 p3(x, dimensions.y, dimensions.z);
        glm::dvec3 p4(x, dimensions.y, 0);

        glm::dvec3 norm((x == dimensions.x) ? 1 : -1, 0, 0);

        if (x == 0) {
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p2);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);

            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p4);
            pushBackVec3(vertices, norm);
        }
        else {
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p2);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);

            pushBackVec3(vertices, p4);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
        }
    }

    for (double y = 0; y <= dimensions.y; y += dimensions.y) {
        glm::dvec3 p1(0, y, 0);
        glm::dvec3 p2(0, y, dimensions.z);
        glm::dvec3 p3(dimensions.x, y, dimensions.z);
        glm::dvec3 p4(dimensions.x, y, 0);

        glm::dvec3 norm(0, (y == dimensions.y) ? 1 : -1, 0);

        if (y == 0) {
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p2);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);

            pushBackVec3(vertices, p4);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
        }
        else {
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p2);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);

            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p4);
            pushBackVec3(vertices, norm);
        }
    }

    for (double z = 0; z <= dimensions.z; z += dimensions.z) {
        glm::dvec3 p1(0, 0, z);
        glm::dvec3 p2(dimensions.x, 0, z);
        glm::dvec3 p3(dimensions.x, dimensions.y, z);
        glm::dvec3 p4(0, dimensions.y, z);

        glm::dvec3 norm(0, 0, (z == dimensions.z) ? 1 : -1);

        if (z == 0) {
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p2);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);

            pushBackVec3(vertices, p4);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
        }
        else {
            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p2);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);

            pushBackVec3(vertices, p1);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p3);
            pushBackVec3(vertices, norm);
            pushBackVec3(vertices, p4);
            pushBackVec3(vertices, norm);
        }
    }

    for (int i = 0; i < vertices.size(); i += 6) {
        for (int j = 0; j < 3; j++) {
            vertices[i + j] += pos[j];
        }
    }

    return vertices;
}

#endif

